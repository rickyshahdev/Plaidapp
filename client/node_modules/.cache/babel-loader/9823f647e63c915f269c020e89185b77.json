{"ast":null,"code":"'use strict';\n\nvar R = require('ramda');\n\nvar axios = require('axios');\n\nvar pjson = require('../package.json');\n\nvar PlaidError = require('./PlaidError');\n\nvar wrapPromise = require('./wrapPromise'); // Max timeout of ten minutes\n\n\nvar DEFAULT_TIMEOUT_IN_MILLIS = 10 * 60 * 1000;\n\nvar rejectWithPlaidError = function rejectWithPlaidError(reject, res) {\n  // plaid error\n  if (R.type(res.data) === 'Object') {\n    res.data.status_code = res.status;\n    return reject(new PlaidError(res.data));\n  } // Unknown body type returned, return a standard API_ERROR\n\n\n  return reject(new PlaidError({\n    error_type: 'API_ERROR',\n    status_code: res.status,\n    error_code: 'INTERNAL_SERVER_ERROR',\n    error_message: String(res.data),\n    display_message: null,\n    request_id: null\n  }));\n};\n\nvar handleApiResponse = function handleApiResponse(resolve, reject, res, isMfa) {\n  var $body = res.data;\n\n  if (res != null && R.type($body) === 'Object') {\n    $body.status_code = res.status;\n  } // success response (MFA)\n\n\n  if (isMfa && res.status === 200) {\n    return resolve([null, $body]); // mfa response (MFA)\n  } else if (isMfa && res.status === 210) {\n    return resolve([$body, null]); // success response (non mfa)\n  } else if (res.status === 200) {\n    // extract request id from header for binary data,\n    // i.e. mime type application/*\n    if (res.headers['plaid-request-id'] != null && res.headers['content-type'] != null && res.headers['content-type'].indexOf('application') === 0) {\n      return resolve({\n        request_id: res.headers['plaid-request-id'],\n        buffer: $body\n      });\n    }\n\n    return resolve($body);\n  } else {\n    return rejectWithPlaidError(reject, res);\n  }\n};\n\nvar plaidRequest = function plaidRequest(context, requestSpec, clientRequestOptions, cb) {\n  var uri = context.env + requestSpec.path;\n  var method = 'POST';\n  var requestJSON = R.merge(R.dissoc('env', context), requestSpec.body);\n  var headers = {\n    'User-Agent': 'Plaid Node v' + pjson.version\n  };\n\n  if (clientRequestOptions.version != null) {\n    headers['Plaid-Version'] = clientRequestOptions.version;\n  }\n\n  if (clientRequestOptions.clientApp != null) {\n    headers['Plaid-Client-App'] = clientRequestOptions.clientApp;\n  } // merge the default request options with the client specified options,\n  // this allows for clients to supply extra options to the request function\n\n\n  var requestOptions = R.merge({\n    url: uri,\n    method: method,\n    data: requestJSON,\n    headers: headers,\n    timeout: DEFAULT_TIMEOUT_IN_MILLIS,\n    responseType: requestSpec.binary ? 'arraybuffer' : 'json'\n  }, clientRequestOptions);\n  return wrapPromise(new Promise(function (resolve, reject) {\n    axios(requestOptions).then(function (res) {\n      handleApiResponse(resolve, reject, res, requestSpec.includeMfaResponse);\n    }).catch(function (error) {\n      if (error.response) {\n        return rejectWithPlaidError(reject, error.response);\n      } else {\n        return reject(error);\n      }\n    });\n  }), cb);\n};\n\nmodule.exports = plaidRequest;","map":null,"metadata":{},"sourceType":"script"}